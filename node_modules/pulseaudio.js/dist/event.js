"use strict";
// Copyright (c) 2019-2021 Jan Janak <jan@janakj.org>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamEvent = exports.SubscribeEvent = exports.Event = exports.PA_SUBSCRIPTION_MASK = void 0;
var packet_1 = require("./packet");
var defs_1 = require("./defs");
var command_1 = require("./command");
var PA_SUBSCRIPTION_EVENT;
(function (PA_SUBSCRIPTION_EVENT) {
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["SINK"] = 0] = "SINK";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["SOURCE"] = 1] = "SOURCE";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["SINK_INPUT"] = 2] = "SINK_INPUT";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["SOURCE_OUTPUT"] = 3] = "SOURCE_OUTPUT";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["MODULE"] = 4] = "MODULE";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["CLIENT"] = 5] = "CLIENT";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["SAMPLE_CACHE"] = 6] = "SAMPLE_CACHE";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["SERVER"] = 7] = "SERVER";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["AUTOLOAD"] = 8] = "AUTOLOAD";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["CARD"] = 9] = "CARD";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["FACILITY_MASK"] = 15] = "FACILITY_MASK";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["NEW"] = 0] = "NEW";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["CHANGE"] = 16] = "CHANGE";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["REMOVE"] = 32] = "REMOVE";
    PA_SUBSCRIPTION_EVENT[PA_SUBSCRIPTION_EVENT["TYPE_MASK"] = 48] = "TYPE_MASK"; // A mask to extract the event operation from an event value
})(PA_SUBSCRIPTION_EVENT || (PA_SUBSCRIPTION_EVENT = {}));
// Must match pulse/def.h
var PA_SUBSCRIPTION_MASK;
(function (PA_SUBSCRIPTION_MASK) {
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["NULL"] = 0] = "NULL";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["SINK"] = 1] = "SINK";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["SOURCE"] = 2] = "SOURCE";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["SINK_INPUT"] = 4] = "SINK_INPUT";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["SOURCE_OUTPUT"] = 8] = "SOURCE_OUTPUT";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["MODULE"] = 16] = "MODULE";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["CLIENT"] = 32] = "CLIENT";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["SAMPLE_CACHE"] = 64] = "SAMPLE_CACHE";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["SERVER"] = 128] = "SERVER";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["AUTOLOAD"] = 256] = "AUTOLOAD";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["CARD"] = 512] = "CARD";
    PA_SUBSCRIPTION_MASK[PA_SUBSCRIPTION_MASK["ALL"] = 767] = "ALL"; // Catch all events
})(PA_SUBSCRIPTION_MASK = exports.PA_SUBSCRIPTION_MASK || (exports.PA_SUBSCRIPTION_MASK = {}));
function eventOperation(event) {
    var op = event & PA_SUBSCRIPTION_EVENT.TYPE_MASK;
    switch (op) {
        case PA_SUBSCRIPTION_EVENT.NEW: return "new";
        case PA_SUBSCRIPTION_EVENT.CHANGE: return "change";
        case PA_SUBSCRIPTION_EVENT.REMOVE: return "remove";
        default: throw new Error("Unsupported event operation " + op);
    }
}
function eventFacility(event) {
    var facility = event & PA_SUBSCRIPTION_EVENT.FACILITY_MASK;
    switch (facility) {
        case PA_SUBSCRIPTION_EVENT.SINK: return "sink";
        case PA_SUBSCRIPTION_EVENT.SOURCE: return "source";
        case PA_SUBSCRIPTION_EVENT.SINK_INPUT: return "sink_input";
        case PA_SUBSCRIPTION_EVENT.SOURCE_OUTPUT: return "source_output";
        case PA_SUBSCRIPTION_EVENT.MODULE: return "module";
        case PA_SUBSCRIPTION_EVENT.CLIENT: return "client";
        case PA_SUBSCRIPTION_EVENT.SAMPLE_CACHE: return "sample_cache";
        case PA_SUBSCRIPTION_EVENT.SERVER: return "server";
        case PA_SUBSCRIPTION_EVENT.AUTOLOAD: return "autoload";
        case PA_SUBSCRIPTION_EVENT.CARD: return "card";
        default: throw new Error("Unsupported event facility " + facility);
    }
}
var Event = /** @class */ (function (_super) {
    __extends(Event, _super);
    function Event(header, body) {
        var _this = _super.call(this, header, body) || this;
        _this.type = _this.getUInt32();
        var tag = _this.getUInt32();
        if (tag !== defs_1.PA_NO_TAG)
            throw new Error("Event packet has the wrong tag " + tag + " (expected " + defs_1.PA_NO_TAG + ")");
        return _this;
    }
    return Event;
}(packet_1.TagStruct));
exports.Event = Event;
var SubscribeEvent = /** @class */ (function (_super) {
    __extends(SubscribeEvent, _super);
    function SubscribeEvent(header, body) {
        var _this = _super.call(this, header, body) || this;
        if (_this.type !== command_1.PA_COMMAND.SUBSCRIBE_EVENT)
            throw new Error("Subscribe event has the wrong type " + _this.type + " (expected PA_COMMAND.SUBSCRIBE_EVENT)");
        _this.event = _this.getUInt32();
        _this.operation = eventOperation(_this.event);
        _this.facility = eventFacility(_this.event);
        _this.index = _this.getUInt32();
        return _this;
    }
    return SubscribeEvent;
}(Event));
exports.SubscribeEvent = SubscribeEvent;
var StreamEvent = /** @class */ (function (_super) {
    __extends(StreamEvent, _super);
    function StreamEvent(header, body) {
        var _this = _super.call(this, header, body) || this;
        _this.index = _this.getUInt32();
        switch (_this.type) {
            case command_1.PA_COMMAND.PLAYBACK_STREAM_EVENT:
            case command_1.PA_COMMAND.RECORD_STREAM_EVENT:
                _this.type = 'event';
                _this.event = _this.getString();
                _this.properties = _this.getProps();
                break;
            case command_1.PA_COMMAND.PLAYBACK_STREAM_SUSPENDED:
            case command_1.PA_COMMAND.RECORD_STREAM_SUSPENDED:
                _this.type = 'suspended';
                _this.suspended = _this.getBool();
                break;
            case command_1.PA_COMMAND.PLAYBACK_STREAM_MOVED:
                _this.parseDestination();
                _this.parsePlaybackBuffer();
                _this.configuredSinkLatency = _this.getUsec();
                _this.type = 'moved';
                break;
            case command_1.PA_COMMAND.PLAYBACK_BUFFER_ATTR_CHANGED:
                _this.parsePlaybackBuffer();
                _this.configuredSinkLatency = _this.getUsec();
                _this.type = 'buffer';
                break;
            case command_1.PA_COMMAND.RECORD_STREAM_MOVED:
                _this.parseDestination();
                _this.buffer = {
                    maximumLength: _this.getUInt32(),
                    fragmentSize: _this.getUInt32()
                };
                _this.configuredSourceLatency = _this.getUsec();
                _this.type = 'moved';
                break;
            case command_1.PA_COMMAND.PLAYBACK_STREAM_KILLED:
            case command_1.PA_COMMAND.RECORD_STREAM_KILLED:
                _this.type = 'killed';
                break;
            case command_1.PA_COMMAND.STARTED:
                _this.type = 'started';
                break;
            case command_1.PA_COMMAND.OVERFLOW:
                _this.type = 'overflow';
                break;
            case command_1.PA_COMMAND.REQUEST:
                _this.requestedBytes = _this.getUInt32();
                _this.type = 'request';
                break;
            case command_1.PA_COMMAND.UNDERFLOW:
                _this.offset = _this.getSInt64();
                _this.type = 'underflow';
                break;
            default:
                throw new Error("Unsupported stream event type " + _this.type);
        }
        return _this;
    }
    StreamEvent.prototype.parsePlaybackBuffer = function () {
        this.buffer = {
            maximumLength: this.getUInt32(),
            targetLength: this.getUInt32(),
            preBuffering: this.getUInt32(),
            minimumRequest: this.getUInt32()
        };
    };
    StreamEvent.prototype.parseDestination = function () {
        this.destination = {
            index: this.getUInt32(),
            name: this.getString(),
            suspended: this.getBool()
        };
    };
    return StreamEvent;
}(Event));
exports.StreamEvent = StreamEvent;
