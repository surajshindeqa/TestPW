"use strict";
// Copyright (c) 2019-2021 Jan Janak <jan@janakj.org>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagStruct = exports.PA_TAG = exports.MemoryBlock = exports.PA_STREAM_DESCRIPTOR_SIZE = exports.PA_STREAM_DESCRIPTOR = void 0;
var defs_1 = require("./defs");
var props_1 = require("./props");
// A fixed-size descriptor that must be transmitted at the beginning of each
// packet. The descriptor consists of 5 32-bit integers in network byte order.
// The first integer contains the length of the packet without the descriptor.
// The second integer is a channel number. The channel number is only used in
// memory block packets. In other cases it is set to PA_NO_INDEX. The third
// and fourth integers are memory block address offsets. The fifth integer
// carries various flags and is set to 0 by default.
//
// Must match pulsecore/pstream.{h,c}
var PA_STREAM_DESCRIPTOR;
(function (PA_STREAM_DESCRIPTOR) {
    PA_STREAM_DESCRIPTOR[PA_STREAM_DESCRIPTOR["LENGTH"] = 0] = "LENGTH";
    PA_STREAM_DESCRIPTOR[PA_STREAM_DESCRIPTOR["CHANNEL"] = 1] = "CHANNEL";
    PA_STREAM_DESCRIPTOR[PA_STREAM_DESCRIPTOR["OFFSET_HI"] = 2] = "OFFSET_HI";
    PA_STREAM_DESCRIPTOR[PA_STREAM_DESCRIPTOR["OFFSET_LO"] = 3] = "OFFSET_LO";
    PA_STREAM_DESCRIPTOR[PA_STREAM_DESCRIPTOR["FLAGS"] = 4] = "FLAGS";
    PA_STREAM_DESCRIPTOR[PA_STREAM_DESCRIPTOR["MAX"] = 5] = "MAX";
})(PA_STREAM_DESCRIPTOR = exports.PA_STREAM_DESCRIPTOR || (exports.PA_STREAM_DESCRIPTOR = {}));
exports.PA_STREAM_DESCRIPTOR_SIZE = PA_STREAM_DESCRIPTOR.MAX * 4;
var Packet = /** @class */ (function () {
    function Packet(header) {
        if (typeof header === 'undefined' || header === null) {
            this.header = Buffer.alloc(exports.PA_STREAM_DESCRIPTOR_SIZE);
        }
        else if (Buffer.isBuffer(header)) {
            this.header = header;
        }
        else {
            throw new Error("Unsupported argument type (must be a Buffer)");
        }
    }
    Packet.prototype.setChannel = function (channel) {
        this.header.writeUInt32BE(channel, PA_STREAM_DESCRIPTOR.CHANNEL * 4);
    };
    Packet.prototype.setLength = function (length) {
        this.header.writeUInt32BE(length, PA_STREAM_DESCRIPTOR.LENGTH * 4);
    };
    Packet.prototype.finalize = function () {
        return [this.header];
    };
    return Packet;
}());
var MemoryBlock = /** @class */ (function (_super) {
    __extends(MemoryBlock, _super);
    function MemoryBlock(headerOrChannel, body) {
        var _this = this;
        if (Buffer.isBuffer(body)) {
            body = [body];
        }
        else if (!Array.isArray(body)) {
            throw new Error('MemoryBlock body must be a Buffer or array of Buffers');
        }
        if (typeof headerOrChannel === 'number') {
            // The first argument is channel number, the second argument is either a
            // single block or an array of blocks. This variant is used in
            // PlaybackStream to send memory blocks to PulseAudio servers.
            _this = _super.call(this) || this;
            _this.setChannel(headerOrChannel);
            _this.setLength(body.reduce(function (a, v) { return a + v.length; }, 0));
        }
        else if (Buffer.isBuffer(headerOrChannel)) {
            // The first argument is a Buffer holding the packet's header. This
            // variant is used for memory blocks incoming from PulseAudio server.
            _this = _super.call(this, headerOrChannel) || this;
        }
        else {
            throw new Error("Invalid arguments to MemoryBlock constructor");
        }
        _this.body = body;
        return _this;
    }
    MemoryBlock.prototype.finalize = function () {
        return _super.prototype.finalize.call(this).concat(this.body);
    };
    return MemoryBlock;
}(Packet));
exports.MemoryBlock = MemoryBlock;
// Must match pulsecore/tagstruct.h
var PA_TAG;
(function (PA_TAG) {
    PA_TAG[PA_TAG["INVALID"] = 0] = "INVALID";
    PA_TAG[PA_TAG["STRING"] = 't'.charCodeAt(0)] = "STRING";
    PA_TAG[PA_TAG["STRING_NULL"] = 'N'.charCodeAt(0)] = "STRING_NULL";
    PA_TAG[PA_TAG["U32"] = 'L'.charCodeAt(0)] = "U32";
    PA_TAG[PA_TAG["U8"] = 'B'.charCodeAt(0)] = "U8";
    PA_TAG[PA_TAG["U64"] = 'R'.charCodeAt(0)] = "U64";
    PA_TAG[PA_TAG["S64"] = 'r'.charCodeAt(0)] = "S64";
    PA_TAG[PA_TAG["SAMPLE_SPEC"] = 'a'.charCodeAt(0)] = "SAMPLE_SPEC";
    PA_TAG[PA_TAG["ARBITRARY"] = 'x'.charCodeAt(0)] = "ARBITRARY";
    PA_TAG[PA_TAG["BOOLEAN_TRUE"] = '1'.charCodeAt(0)] = "BOOLEAN_TRUE";
    PA_TAG[PA_TAG["BOOLEAN_FALSE"] = '0'.charCodeAt(0)] = "BOOLEAN_FALSE";
    PA_TAG[PA_TAG["TIMEVAL"] = 'T'.charCodeAt(0)] = "TIMEVAL";
    PA_TAG[PA_TAG["USEC"] = 'U'.charCodeAt(0)] = "USEC";
    PA_TAG[PA_TAG["CHANNEL_MAP"] = 'm'.charCodeAt(0)] = "CHANNEL_MAP";
    PA_TAG[PA_TAG["CVOLUME"] = 'v'.charCodeAt(0)] = "CVOLUME";
    PA_TAG[PA_TAG["PROPLIST"] = 'P'.charCodeAt(0)] = "PROPLIST";
    PA_TAG[PA_TAG["VOLUME"] = 'V'.charCodeAt(0)] = "VOLUME";
    PA_TAG[PA_TAG["FORMAT_INFO"] = 'f'.charCodeAt(0)] = "FORMAT_INFO";
})(PA_TAG = exports.PA_TAG || (exports.PA_TAG = {}));
var TagStruct = /** @class */ (function (_super) {
    __extends(TagStruct, _super);
    function TagStruct(header, body) {
        var _this = _super.call(this, header) || this;
        if (typeof body === 'undefined' || body === null) {
            // This variant is used when were are creating a new command packet from
            // scratch. This is used in the code that sends commands to PulseAudio
            // server.
            _this.body = Buffer.allocUnsafe(TagStruct.FRAGMENT_SIZE);
        }
        else if (Buffer.isBuffer(body)) {
            _this.body = body;
        }
        else {
            throw new Error('Invalid body argument to TagStruct');
        }
        // Read and write index into the buffer.
        _this.i = 0;
        return _this;
    }
    TagStruct.prototype.alloc = function (wanted) {
        var missing = wanted - this.body.length + this.i;
        if (missing <= 0)
            return;
        var n = missing / TagStruct.FRAGMENT_SIZE +
            ((missing % TagStruct.FRAGMENT_SIZE > 0) ? 1 : 0);
        var buf = Buffer.allocUnsafe(this.body.length + n * TagStruct.FRAGMENT_SIZE);
        this.body.copy(buf, 0, 0, this.i);
        this.body = buf;
    };
    TagStruct.prototype.assert = function (wanted) {
        if (this.body.length - this.i < wanted)
            throw new Error("Packet too short (wanted " + wanted + " bytes)");
    };
    TagStruct.prototype.finalize = function () {
        this.setLength(this.i);
        return _super.prototype.finalize.call(this).concat(this.body.slice(0, this.i));
    };
    TagStruct.prototype.addUInt8 = function (value) {
        this.alloc(2);
        this.body[this.i++] = PA_TAG.U8;
        this.body[this.i++] = value;
    };
    TagStruct.prototype.getUInt8 = function () {
        this.assert(2);
        if (this.body[this.i] !== PA_TAG.U8)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.U8");
        this.i++;
        return this.body.readUInt8(this.i++);
    };
    TagStruct.prototype.addUInt32 = function (value) {
        this.alloc(5);
        this.body[this.i++] = PA_TAG.U32;
        this.i = this.body.writeUInt32BE(value, this.i);
    };
    TagStruct.prototype.getUInt32 = function () {
        this.assert(5);
        if (this.body[this.i] !== PA_TAG.U32)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.U32");
        var rv = this.body.readUInt32BE(this.i + 1);
        this.i += 5;
        return rv;
    };
    TagStruct.prototype.addUInt64 = function (value) {
        this.alloc(9);
        this.body[this.i++] = PA_TAG.U64;
        // eslint-disable-next-line no-undef
        this.i = this.body.writeBigInt64BE(BigInt(value), this.i);
    };
    TagStruct.prototype.getUInt64 = function () {
        this.assert(9);
        if (this.body[this.i] !== PA_TAG.U64)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.U64");
        var rv = this.body.readBigUInt64BE(this.i + 1);
        this.i += 9;
        return rv;
    };
    TagStruct.prototype.getSInt64 = function () {
        this.assert(9);
        if (this.body[this.i] !== PA_TAG.S64)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.S64");
        var rv = this.body.readBigInt64BE(this.i + 1);
        this.i += 9;
        return rv;
    };
    TagStruct.prototype.getUsec = function () {
        this.assert(9);
        if (this.body[this.i] !== PA_TAG.USEC)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.USEC");
        this.i++;
        var rv = this.body.readBigInt64BE();
        this.i += 8;
        return rv;
    };
    TagStruct.stringLength = function (value) {
        if (value === null)
            return 1;
        return 2 + Buffer.byteLength(value);
    };
    TagStruct.prototype.addString = function (value) {
        this.alloc(TagStruct.stringLength(value));
        if (value !== null) {
            if (typeof value !== 'string')
                throw new Error('PA_TAG.STRING value must be a string or null');
            this.body[this.i++] = PA_TAG.STRING;
            this.i += this.body.write(value, this.i);
            this.body[this.i++] = 0;
        }
        else {
            this.body[this.i++] = PA_TAG.STRING_NULL;
        }
    };
    TagStruct.prototype.getString = function () {
        this.assert(1);
        if (this.body[this.i] === PA_TAG.STRING_NULL) {
            this.i++;
            return null;
        }
        if (this.body[this.i] === PA_TAG.STRING) {
            this.i++;
            var j = this.i;
            for (; j < this.body.length; j++) {
                if (this.body[j] === 0)
                    break;
            }
            if (j === this.body.length)
                throw new Error('Unterminated string tag');
            var rv = this.body.toString('utf8', this.i, j);
            this.i = j + 1;
            return rv;
        }
        throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.STRING_NULL or PA_TAG.STRING");
    };
    TagStruct.prototype.addArbitrary = function (value) {
        if (!Buffer.isBuffer(value))
            throw new Error("Value for PA_TAG.ARBITRARY must be a buffer");
        this.alloc(value.length + 5);
        this.body[this.i++] = PA_TAG.ARBITRARY;
        this.i = this.body.writeUInt32BE(value.length, this.i);
        if (value.length)
            this.i += value.copy(this.body, this.i);
    };
    TagStruct.prototype.getArbitrary = function () {
        this.assert(5);
        if (this.body[this.i] !== PA_TAG.ARBITRARY)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.ARBITRARY");
        this.i++;
        var len = this.body.readUInt32BE(this.i);
        this.i += 4;
        var data;
        if (len > 0) {
            this.assert(len);
            data = Buffer.from(this.body.buffer, this.body.byteOffset + this.i, len);
        }
        else {
            data = Buffer.alloc(0);
        }
        this.i += len;
        return data;
    };
    TagStruct.prototype.addBool = function (value) {
        this.alloc(1);
        this.body[this.i++] = value ? PA_TAG.BOOLEAN_TRUE : PA_TAG.BOOLEAN_FALSE;
    };
    TagStruct.prototype.getBool = function () {
        this.assert(1);
        var val;
        if (this.body[this.i] === PA_TAG.BOOLEAN_TRUE)
            val = true;
        else if (this.body[this.i] === PA_TAG.BOOLEAN_FALSE)
            val = false;
        else
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.BOOLEAN_{TRUE,FALSE}");
        this.i++;
        return val;
    };
    TagStruct.propsLength = function (props) {
        var rv = 1;
        for (var _i = 0, _a = Object.entries(props); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], val = _b[1];
            rv += TagStruct.stringLength(key);
            rv += 5;
            rv += 5 + val.length + 1;
        }
        rv += 1;
        return rv;
    };
    TagStruct.prototype.addProps = function (props) {
        var p = (0, props_1.deflate)(props);
        this.alloc(TagStruct.propsLength(p));
        this.body[this.i++] = PA_TAG.PROPLIST;
        for (var _i = 0, _a = Object.entries(p); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], val = _b[1];
            this.addString(key);
            var buf = Buffer.allocUnsafe(val.length + 1);
            buf.write(val);
            buf[val.length] = 0;
            this.addUInt32(buf.length);
            this.addArbitrary(buf);
        }
        this.addString(null);
    };
    TagStruct.prototype.getProps = function () {
        this.assert(1);
        if (this.body[this.i] !== PA_TAG.PROPLIST)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.PROPLIST");
        this.i++;
        var props = Object.create(null);
        var key = this.getString();
        while (key !== null) {
            this.getUInt32();
            var val = this.getArbitrary();
            // Prop value strings include zero terminators. Do not copy that into the
            // returned string
            props[key] = val.toString('utf8', 0, val.length - 1);
            key = this.getString();
        }
        return (0, props_1.inflate)(props);
    };
    TagStruct.cvolumeLength = function (volumes) {
        return 2 + volumes.length * 4;
    };
    TagStruct.prototype.addCvolume = function (volumes) {
        this.alloc(TagStruct.cvolumeLength(volumes));
        this.body[this.i++] = PA_TAG.CVOLUME;
        this.body[this.i++] = volumes.length;
        for (var _i = 0, volumes_1 = volumes; _i < volumes_1.length; _i++) {
            var volume = volumes_1[_i];
            this.i = this.body.writeUInt32BE(volume, this.i);
        }
    };
    TagStruct.prototype.getCvolume = function () {
        this.assert(2);
        if (this.body[this.i] !== PA_TAG.CVOLUME)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.CVOLUME");
        this.i++;
        var len = this.body[this.i++];
        this.assert(len * 4);
        var rv = [];
        for (var i = 0; i < len; i++) {
            rv.push(this.body.readUInt32BE(this.i));
            this.i += 4;
        }
        return rv;
    };
    TagStruct.prototype.addVolume = function (volume) {
        this.alloc(5);
        this.body[this.i++] = PA_TAG.VOLUME;
        this.i = this.body.writeUInt32BE(volume, this.i);
    };
    TagStruct.prototype.getVolume = function () {
        this.assert(5);
        if (this.body[this.i] !== PA_TAG.VOLUME)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.VOLUME");
        var rv = this.body.readUInt32BE(this.i + 1);
        this.i += 5;
        return rv;
    };
    TagStruct.sampleSpecLength = function () {
        return 7;
    };
    TagStruct.prototype.addSampleSpec = function (_a) {
        var format = _a.format, channels = _a.channels, rate = _a.rate;
        this.alloc(TagStruct.sampleSpecLength());
        this.body[this.i++] = PA_TAG.SAMPLE_SPEC;
        if (typeof format !== 'number')
            throw new Error("Sample format must be a number");
        if (!(format in defs_1.PA_SAMPLE_FORMAT))
            throw new Error("Invalid sample format " + format);
        this.body[this.i++] = format;
        if (typeof channels !== 'number')
            throw new Error("Number of channels must be a number");
        if (channels < 0 || channels >= defs_1.PA_MAX_CHANNELS)
            throw new Error("Invalid number of channels: " + channels);
        this.body[this.i++] = channels;
        this.i = this.body.writeUInt32BE(rate, this.i);
    };
    TagStruct.prototype.getSampleSpec = function () {
        this.assert(TagStruct.sampleSpecLength());
        if (this.body[this.i] !== PA_TAG.SAMPLE_SPEC)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.SAMPLE_SPEC");
        this.i++;
        var rv = {
            format: this.body[this.i++],
            channels: this.body[this.i++],
            rate: this.body.readUInt32BE(this.i)
        };
        this.i += 4;
        return rv;
    };
    TagStruct.channelMapLength = function (map) {
        if (!Array.isArray(map))
            throw new Error('Channel map must be an array');
        if (map.length > 255)
            throw new Error("More than 255 channels in channel map: " + map.length);
        return 2 + map.length;
    };
    TagStruct.prototype.addChannelMap = function (map) {
        this.alloc(TagStruct.channelMapLength(map));
        this.body[this.i++] = PA_TAG.CHANNEL_MAP;
        this.body[this.i++] = map.length;
        for (var j = 0; j < map.length; j++)
            this.body[this.i++] = map[j];
    };
    TagStruct.prototype.getChannelMap = function () {
        this.assert(2);
        if (this.body[this.i] !== PA_TAG.CHANNEL_MAP)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.CHANNEL_MAP");
        this.i++;
        var channels = this.body[this.i++];
        this.assert(channels);
        var j = 0;
        var map = [];
        for (; j < channels; j++)
            map.push(this.body[this.i + j]);
        this.i += j;
        return map;
    };
    TagStruct.prototype.getFormatInfo = function () {
        this.assert(1);
        if (this.body[this.i] !== PA_TAG.FORMAT_INFO)
            throw new Error("Invalid tag " + this.body[this.i] + ", expected PA_TAG.FORMAT_INFO");
        this.i++;
        return {
            encoding: this.getUInt8(),
            properties: this.getProps()
        };
    };
    TagStruct.prototype.addFormatInfo = function (encoding, props) {
        if (props === void 0) { props = {}; }
        this.alloc(1);
        this.body[this.i++] = PA_TAG.FORMAT_INFO;
        this.addUInt8(encoding);
        this.addProps(props);
    };
    TagStruct.FRAGMENT_SIZE = 64;
    return TagStruct;
}(Packet));
exports.TagStruct = TagStruct;
