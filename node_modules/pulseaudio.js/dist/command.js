"use strict";
// Copyright (c) 2019-2021 Jan Janak <jan@janakj.org>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Move = exports.GetSourceOutputList = exports.GetSinkInputList = exports.GetClientsList = exports.CreateRecordStream = exports.CreateUploadStream = exports.CreatePlaybackStream = exports.GetSourceOutputInfo = exports.GetSinkInputInfo = exports.Subscribe = exports.PlaySample = exports.LoadModule = exports.GetSourceSinkInfoList = exports.GetSourceSinkInfo = exports.Lookup = exports.SetMuteByIndex = exports.SetMute = exports.SetVolumeByIndex = exports.SetVolume = exports.SelectByNameOrIndex = exports.SelectByName = exports.SelectByIndex = exports.GetServerInfo = exports.SetClientName = exports.Auth = exports.Command = exports.PA_COMMAND = void 0;
var defs_1 = require("./defs");
var packet_1 = require("./packet");
var props_1 = require("./props");
var stream_1 = require("./stream");
var volume_1 = require("./volume");
var wav_1 = require("./wav");
var debug = defs_1.logger.extend('cmd');
var PA_MIN_INDEX = 0;
var PA_NO_CHANNEL = defs_1.PA_NO_VALUE;
var PA_MAX_INDEX = 0xfffffffe;
// A global syncId counter that is used to generate a unique syncId to each
// newly created playback stream unless the client overrides the value.
var syncIdCounter = 0;
var requestTag = 0xfffffffe;
function getRequestTag() {
    requestTag = (requestTag + 1) % 0xfffffffe;
    return requestTag;
}
// Must match pulsecore/native-common.h
var PA_COMMAND;
(function (PA_COMMAND) {
    /* Generic commands */
    PA_COMMAND[PA_COMMAND["ERROR"] = 0] = "ERROR";
    PA_COMMAND[PA_COMMAND["TIMEOUT"] = 1] = "TIMEOUT";
    PA_COMMAND[PA_COMMAND["REPLY"] = 2] = "REPLY";
    /* CLIENT->SERVER */
    PA_COMMAND[PA_COMMAND["CREATE_PLAYBACK_STREAM"] = 3] = "CREATE_PLAYBACK_STREAM";
    PA_COMMAND[PA_COMMAND["DELETE_PLAYBACK_STREAM"] = 4] = "DELETE_PLAYBACK_STREAM";
    PA_COMMAND[PA_COMMAND["CREATE_RECORD_STREAM"] = 5] = "CREATE_RECORD_STREAM";
    PA_COMMAND[PA_COMMAND["DELETE_RECORD_STREAM"] = 6] = "DELETE_RECORD_STREAM";
    PA_COMMAND[PA_COMMAND["EXIT"] = 7] = "EXIT";
    PA_COMMAND[PA_COMMAND["AUTH"] = 8] = "AUTH";
    PA_COMMAND[PA_COMMAND["SET_CLIENT_NAME"] = 9] = "SET_CLIENT_NAME";
    PA_COMMAND[PA_COMMAND["LOOKUP_SINK"] = 10] = "LOOKUP_SINK";
    PA_COMMAND[PA_COMMAND["LOOKUP_SOURCE"] = 11] = "LOOKUP_SOURCE";
    PA_COMMAND[PA_COMMAND["DRAIN_PLAYBACK_STREAM"] = 12] = "DRAIN_PLAYBACK_STREAM";
    PA_COMMAND[PA_COMMAND["STAT"] = 13] = "STAT";
    PA_COMMAND[PA_COMMAND["GET_PLAYBACK_LATENCY"] = 14] = "GET_PLAYBACK_LATENCY";
    PA_COMMAND[PA_COMMAND["CREATE_UPLOAD_STREAM"] = 15] = "CREATE_UPLOAD_STREAM";
    PA_COMMAND[PA_COMMAND["DELETE_UPLOAD_STREAM"] = 16] = "DELETE_UPLOAD_STREAM";
    PA_COMMAND[PA_COMMAND["FINISH_UPLOAD_STREAM"] = 17] = "FINISH_UPLOAD_STREAM";
    PA_COMMAND[PA_COMMAND["PLAY_SAMPLE"] = 18] = "PLAY_SAMPLE";
    PA_COMMAND[PA_COMMAND["REMOVE_SAMPLE"] = 19] = "REMOVE_SAMPLE";
    PA_COMMAND[PA_COMMAND["GET_SERVER_INFO"] = 20] = "GET_SERVER_INFO";
    PA_COMMAND[PA_COMMAND["GET_SINK_INFO"] = 21] = "GET_SINK_INFO";
    PA_COMMAND[PA_COMMAND["GET_SINK_INFO_LIST"] = 22] = "GET_SINK_INFO_LIST";
    PA_COMMAND[PA_COMMAND["GET_SOURCE_INFO"] = 23] = "GET_SOURCE_INFO";
    PA_COMMAND[PA_COMMAND["GET_SOURCE_INFO_LIST"] = 24] = "GET_SOURCE_INFO_LIST";
    PA_COMMAND[PA_COMMAND["GET_MODULE_INFO"] = 25] = "GET_MODULE_INFO";
    PA_COMMAND[PA_COMMAND["GET_MODULE_INFO_LIST"] = 26] = "GET_MODULE_INFO_LIST";
    PA_COMMAND[PA_COMMAND["GET_CLIENT_INFO"] = 27] = "GET_CLIENT_INFO";
    PA_COMMAND[PA_COMMAND["GET_CLIENT_INFO_LIST"] = 28] = "GET_CLIENT_INFO_LIST";
    PA_COMMAND[PA_COMMAND["GET_SINK_INPUT_INFO"] = 29] = "GET_SINK_INPUT_INFO";
    PA_COMMAND[PA_COMMAND["GET_SINK_INPUT_INFO_LIST"] = 30] = "GET_SINK_INPUT_INFO_LIST";
    PA_COMMAND[PA_COMMAND["GET_SOURCE_OUTPUT_INFO"] = 31] = "GET_SOURCE_OUTPUT_INFO";
    PA_COMMAND[PA_COMMAND["GET_SOURCE_OUTPUT_INFO_LIST"] = 32] = "GET_SOURCE_OUTPUT_INFO_LIST";
    PA_COMMAND[PA_COMMAND["GET_SAMPLE_INFO"] = 33] = "GET_SAMPLE_INFO";
    PA_COMMAND[PA_COMMAND["GET_SAMPLE_INFO_LIST"] = 34] = "GET_SAMPLE_INFO_LIST";
    PA_COMMAND[PA_COMMAND["SUBSCRIBE"] = 35] = "SUBSCRIBE";
    PA_COMMAND[PA_COMMAND["SET_SINK_VOLUME"] = 36] = "SET_SINK_VOLUME";
    PA_COMMAND[PA_COMMAND["SET_SINK_INPUT_VOLUME"] = 37] = "SET_SINK_INPUT_VOLUME";
    PA_COMMAND[PA_COMMAND["SET_SOURCE_VOLUME"] = 38] = "SET_SOURCE_VOLUME";
    PA_COMMAND[PA_COMMAND["SET_SINK_MUTE"] = 39] = "SET_SINK_MUTE";
    PA_COMMAND[PA_COMMAND["SET_SOURCE_MUTE"] = 40] = "SET_SOURCE_MUTE";
    PA_COMMAND[PA_COMMAND["CORK_PLAYBACK_STREAM"] = 41] = "CORK_PLAYBACK_STREAM";
    PA_COMMAND[PA_COMMAND["FLUSH_PLAYBACK_STREAM"] = 42] = "FLUSH_PLAYBACK_STREAM";
    PA_COMMAND[PA_COMMAND["TRIGGER_PLAYBACK_STREAM"] = 43] = "TRIGGER_PLAYBACK_STREAM";
    PA_COMMAND[PA_COMMAND["SET_DEFAULT_SINK"] = 44] = "SET_DEFAULT_SINK";
    PA_COMMAND[PA_COMMAND["SET_DEFAULT_SOURCE"] = 45] = "SET_DEFAULT_SOURCE";
    PA_COMMAND[PA_COMMAND["SET_PLAYBACK_STREAM_NAME"] = 46] = "SET_PLAYBACK_STREAM_NAME";
    PA_COMMAND[PA_COMMAND["SET_RECORD_STREAM_NAME"] = 47] = "SET_RECORD_STREAM_NAME";
    PA_COMMAND[PA_COMMAND["KILL_CLIENT"] = 48] = "KILL_CLIENT";
    PA_COMMAND[PA_COMMAND["KILL_SINK_INPUT"] = 49] = "KILL_SINK_INPUT";
    PA_COMMAND[PA_COMMAND["KILL_SOURCE_OUTPUT"] = 50] = "KILL_SOURCE_OUTPUT";
    PA_COMMAND[PA_COMMAND["LOAD_MODULE"] = 51] = "LOAD_MODULE";
    PA_COMMAND[PA_COMMAND["UNLOAD_MODULE"] = 52] = "UNLOAD_MODULE";
    /* Obsolete */
    PA_COMMAND[PA_COMMAND["ADD_AUTOLOAD___OBSOLETE"] = 53] = "ADD_AUTOLOAD___OBSOLETE";
    PA_COMMAND[PA_COMMAND["REMOVE_AUTOLOAD___OBSOLETE"] = 54] = "REMOVE_AUTOLOAD___OBSOLETE";
    PA_COMMAND[PA_COMMAND["GET_AUTOLOAD_INFO___OBSOLETE"] = 55] = "GET_AUTOLOAD_INFO___OBSOLETE";
    PA_COMMAND[PA_COMMAND["GET_AUTOLOAD_INFO_LIST___OBSOLETE"] = 56] = "GET_AUTOLOAD_INFO_LIST___OBSOLETE";
    PA_COMMAND[PA_COMMAND["GET_RECORD_LATENCY"] = 57] = "GET_RECORD_LATENCY";
    PA_COMMAND[PA_COMMAND["CORK_RECORD_STREAM"] = 58] = "CORK_RECORD_STREAM";
    PA_COMMAND[PA_COMMAND["FLUSH_RECORD_STREAM"] = 59] = "FLUSH_RECORD_STREAM";
    PA_COMMAND[PA_COMMAND["PREBUF_PLAYBACK_STREAM"] = 60] = "PREBUF_PLAYBACK_STREAM";
    /* SERVER->CLIENT */
    PA_COMMAND[PA_COMMAND["REQUEST"] = 61] = "REQUEST";
    PA_COMMAND[PA_COMMAND["OVERFLOW"] = 62] = "OVERFLOW";
    PA_COMMAND[PA_COMMAND["UNDERFLOW"] = 63] = "UNDERFLOW";
    PA_COMMAND[PA_COMMAND["PLAYBACK_STREAM_KILLED"] = 64] = "PLAYBACK_STREAM_KILLED";
    PA_COMMAND[PA_COMMAND["RECORD_STREAM_KILLED"] = 65] = "RECORD_STREAM_KILLED";
    PA_COMMAND[PA_COMMAND["SUBSCRIBE_EVENT"] = 66] = "SUBSCRIBE_EVENT";
    /* A few more client->server commands */
    /* Supported since protocol v10 (0.9.5) */
    PA_COMMAND[PA_COMMAND["MOVE_SINK_INPUT"] = 67] = "MOVE_SINK_INPUT";
    PA_COMMAND[PA_COMMAND["MOVE_SOURCE_OUTPUT"] = 68] = "MOVE_SOURCE_OUTPUT";
    /* Supported since protocol v11 (0.9.7) */
    PA_COMMAND[PA_COMMAND["SET_SINK_INPUT_MUTE"] = 69] = "SET_SINK_INPUT_MUTE";
    PA_COMMAND[PA_COMMAND["SUSPEND_SINK"] = 70] = "SUSPEND_SINK";
    PA_COMMAND[PA_COMMAND["SUSPEND_SOURCE"] = 71] = "SUSPEND_SOURCE";
    /* Supported since protocol v12 (0.9.8) */
    PA_COMMAND[PA_COMMAND["SET_PLAYBACK_STREAM_BUFFER_ATTR"] = 72] = "SET_PLAYBACK_STREAM_BUFFER_ATTR";
    PA_COMMAND[PA_COMMAND["SET_RECORD_STREAM_BUFFER_ATTR"] = 73] = "SET_RECORD_STREAM_BUFFER_ATTR";
    PA_COMMAND[PA_COMMAND["UPDATE_PLAYBACK_STREAM_SAMPLE_RATE"] = 74] = "UPDATE_PLAYBACK_STREAM_SAMPLE_RATE";
    PA_COMMAND[PA_COMMAND["UPDATE_RECORD_STREAM_SAMPLE_RATE"] = 75] = "UPDATE_RECORD_STREAM_SAMPLE_RATE";
    /* SERVER->CLIENT */
    PA_COMMAND[PA_COMMAND["PLAYBACK_STREAM_SUSPENDED"] = 76] = "PLAYBACK_STREAM_SUSPENDED";
    PA_COMMAND[PA_COMMAND["RECORD_STREAM_SUSPENDED"] = 77] = "RECORD_STREAM_SUSPENDED";
    PA_COMMAND[PA_COMMAND["PLAYBACK_STREAM_MOVED"] = 78] = "PLAYBACK_STREAM_MOVED";
    PA_COMMAND[PA_COMMAND["RECORD_STREAM_MOVED"] = 79] = "RECORD_STREAM_MOVED";
    /* Supported since protocol v13 (0.9.11) */
    PA_COMMAND[PA_COMMAND["UPDATE_RECORD_STREAM_PROPLIST"] = 80] = "UPDATE_RECORD_STREAM_PROPLIST";
    PA_COMMAND[PA_COMMAND["UPDATE_PLAYBACK_STREAM_PROPLIST"] = 81] = "UPDATE_PLAYBACK_STREAM_PROPLIST";
    PA_COMMAND[PA_COMMAND["UPDATE_CLIENT_PROPLIST"] = 82] = "UPDATE_CLIENT_PROPLIST";
    PA_COMMAND[PA_COMMAND["REMOVE_RECORD_STREAM_PROPLIST"] = 83] = "REMOVE_RECORD_STREAM_PROPLIST";
    PA_COMMAND[PA_COMMAND["REMOVE_PLAYBACK_STREAM_PROPLIST"] = 84] = "REMOVE_PLAYBACK_STREAM_PROPLIST";
    PA_COMMAND[PA_COMMAND["REMOVE_CLIENT_PROPLIST"] = 85] = "REMOVE_CLIENT_PROPLIST";
    /* SERVER->CLIENT */
    PA_COMMAND[PA_COMMAND["STARTED"] = 86] = "STARTED";
    /* Supported since protocol v14 (0.9.12) */
    PA_COMMAND[PA_COMMAND["EXTENSION"] = 87] = "EXTENSION";
    /* Supported since protocol v15 (0.9.15) */
    PA_COMMAND[PA_COMMAND["GET_CARD_INFO"] = 88] = "GET_CARD_INFO";
    PA_COMMAND[PA_COMMAND["GET_CARD_INFO_LIST"] = 89] = "GET_CARD_INFO_LIST";
    PA_COMMAND[PA_COMMAND["SET_CARD_PROFILE"] = 90] = "SET_CARD_PROFILE";
    PA_COMMAND[PA_COMMAND["CLIENT_EVENT"] = 91] = "CLIENT_EVENT";
    PA_COMMAND[PA_COMMAND["PLAYBACK_STREAM_EVENT"] = 92] = "PLAYBACK_STREAM_EVENT";
    PA_COMMAND[PA_COMMAND["RECORD_STREAM_EVENT"] = 93] = "RECORD_STREAM_EVENT";
    /* SERVER->CLIENT */
    PA_COMMAND[PA_COMMAND["PLAYBACK_BUFFER_ATTR_CHANGED"] = 94] = "PLAYBACK_BUFFER_ATTR_CHANGED";
    PA_COMMAND[PA_COMMAND["RECORD_BUFFER_ATTR_CHANGED"] = 95] = "RECORD_BUFFER_ATTR_CHANGED";
    /* Supported since protocol v16 (0.9.16) */
    PA_COMMAND[PA_COMMAND["SET_SINK_PORT"] = 96] = "SET_SINK_PORT";
    PA_COMMAND[PA_COMMAND["SET_SOURCE_PORT"] = 97] = "SET_SOURCE_PORT";
    /* Supported since protocol v22 (1.0) */
    PA_COMMAND[PA_COMMAND["SET_SOURCE_OUTPUT_VOLUME"] = 98] = "SET_SOURCE_OUTPUT_VOLUME";
    PA_COMMAND[PA_COMMAND["SET_SOURCE_OUTPUT_MUTE"] = 99] = "SET_SOURCE_OUTPUT_MUTE";
    /* Supported since protocol v27 (3.0) */
    PA_COMMAND[PA_COMMAND["SET_PORT_LATENCY_OFFSET"] = 100] = "SET_PORT_LATENCY_OFFSET";
    /* Supported since protocol v30 (6.0) */
    /* BOTH DIRECTIONS */
    PA_COMMAND[PA_COMMAND["ENABLE_SRBCHANNEL"] = 101] = "ENABLE_SRBCHANNEL";
    PA_COMMAND[PA_COMMAND["DISABLE_SRBCHANNEL"] = 102] = "DISABLE_SRBCHANNEL";
    /* Supported since protocol v31 (9.0)
     * BOTH DIRECTIONS */
    PA_COMMAND[PA_COMMAND["REGISTER_MEMFD_SHMID"] = 103] = "REGISTER_MEMFD_SHMID";
    PA_COMMAND[PA_COMMAND["MAX"] = 104] = "MAX";
})(PA_COMMAND = exports.PA_COMMAND || (exports.PA_COMMAND = {}));
var Command = /** @class */ (function (_super) {
    __extends(Command, _super);
    function Command(cmdOrBody, header) {
        var _this = this;
        if (Buffer.isBuffer(cmdOrBody)) {
            _this = _super.call(this, header, cmdOrBody) || this;
            _this.type = _this.getUInt32();
            _this.tag = _this.getUInt32();
        }
        else if (typeof cmdOrBody === 'number') {
            _this = _super.call(this, header) || this;
            _this.setChannel(PA_NO_CHANNEL); // Command packets must have the descriptor channel field set to 0xffffffff
            _this.type = cmdOrBody;
            _this.addUInt32(cmdOrBody);
            _this.tag = getRequestTag();
            _this.addUInt32(_this.tag);
        }
        else {
            throw new Error("First argument to Command must be a Buffer or number");
        }
        return _this;
    }
    return Command;
}(packet_1.TagStruct));
exports.Command = Command;
var Auth = /** @class */ (function (_super) {
    __extends(Auth, _super);
    function Auth(cookie, proto) {
        var _this = _super.call(this, PA_COMMAND.AUTH) || this;
        // When connecting over a UNIX domain socket, the server checks the uid and
        // git of the remote process and if it matches the uid and git of the
        // PulseAudio daemon, it does not check the cookie. However, even in that
        // case the daemon expects that the client sends some cookie. If no cookie
        // was provided by the user, create an empty one here.
        if (!cookie) {
            debug("No authentication cookie provided, proceeding with uid/gid authentication");
            cookie = Buffer.alloc(defs_1.PA_NATIVE_COOKIE_LENGTH);
        }
        if (cookie.length !== defs_1.PA_NATIVE_COOKIE_LENGTH)
            throw new Error('Invalid cookie');
        _this.addUInt32(proto || defs_1.PA_NATIVE_PROTOCOL_VERSION);
        _this.addArbitrary(cookie);
        return _this;
    }
    Auth.prototype.processResponse = function (packet) {
        var v = packet.getUInt32();
        // In recent Pulseaudio protocol version the most significant bytes are
        // reserved for flags related to shared memory support.
        return v & Auth.PA_PROTOCOL_VERSION_MASK;
    };
    Auth.PA_PROTOCOL_VERSION_MASK = 0xffff;
    return Auth;
}(Command));
exports.Auth = Auth;
var SetClientName = /** @class */ (function (_super) {
    __extends(SetClientName, _super);
    function SetClientName(nameOrProps) {
        var _this = _super.call(this, PA_COMMAND.SET_CLIENT_NAME) || this;
        var props;
        if (typeof nameOrProps === 'string')
            props = { application: { name: nameOrProps } };
        else
            props = Object.assign(nameOrProps);
        _this.addProps(props);
        return _this;
    }
    SetClientName.prototype.processResponse = function (packet) {
        return packet.getUInt32();
    };
    return SetClientName;
}(Command));
exports.SetClientName = SetClientName;
var GetServerInfo = /** @class */ (function (_super) {
    __extends(GetServerInfo, _super);
    function GetServerInfo() {
        return _super.call(this, PA_COMMAND.GET_SERVER_INFO) || this;
    }
    GetServerInfo.prototype.processResponse = function (packet) {
        var _a, _b, _c, _d, _e, _f;
        return {
            name: (_a = packet.getString()) !== null && _a !== void 0 ? _a : '',
            version: (_b = packet.getString()) !== null && _b !== void 0 ? _b : '',
            username: (_c = packet.getString()) !== null && _c !== void 0 ? _c : '',
            hostname: (_d = packet.getString()) !== null && _d !== void 0 ? _d : '',
            sampleSpec: packet.getSampleSpec(),
            defaultSink: (_e = packet.getString()) !== null && _e !== void 0 ? _e : '',
            defaultSource: (_f = packet.getString()) !== null && _f !== void 0 ? _f : '',
            cookie: packet.getUInt32(),
            defaultChannelMap: packet.getChannelMap() // if procol version >= 15
        };
    };
    return GetServerInfo;
}(Command));
exports.GetServerInfo = GetServerInfo;
var SelectByIndex = /** @class */ (function (_super) {
    __extends(SelectByIndex, _super);
    function SelectByIndex(cmd, index) {
        var _this = this;
        if (typeof index !== 'number')
            throw new Error('Index value must be a number');
        if ((index < PA_MIN_INDEX || index > PA_MAX_INDEX) && index !== defs_1.PA_NO_INDEX)
            throw new Error('Index value out of range');
        _this = _super.call(this, cmd) || this;
        _this.addUInt32(index);
        return _this;
    }
    return SelectByIndex;
}(Command));
exports.SelectByIndex = SelectByIndex;
var SelectByName = /** @class */ (function (_super) {
    __extends(SelectByName, _super);
    function SelectByName(cmd, name) {
        var _this = _super.call(this, cmd) || this;
        if (name !== null && typeof name !== 'string')
            throw new Error("Name must be a string or null");
        _this.addString(name);
        return _this;
    }
    return SelectByName;
}(Command));
exports.SelectByName = SelectByName;
var SelectByNameOrIndex = /** @class */ (function (_super) {
    __extends(SelectByNameOrIndex, _super);
    function SelectByNameOrIndex(cmd, nameOrIndex) {
        var _this = this;
        if (typeof nameOrIndex === 'number') {
            _this = _super.call(this, cmd, nameOrIndex) || this;
            _this.addString(null);
        }
        else if (typeof nameOrIndex === 'string' || nameOrIndex === null) {
            _this = _super.call(this, cmd, defs_1.PA_NO_INDEX) || this;
            _this.addString(nameOrIndex);
        }
        else {
            throw new Error('Sink/source name must be a number, string, or null');
        }
        return _this;
    }
    return SelectByNameOrIndex;
}(SelectByIndex));
exports.SelectByNameOrIndex = SelectByNameOrIndex;
var SetVolume = /** @class */ (function (_super) {
    __extends(SetVolume, _super);
    function SetVolume(cmd, nameOrIndex, volumes) {
        var _this = _super.call(this, cmd, nameOrIndex) || this;
        if (!Array.isArray(volumes))
            volumes = [volumes];
        if (volumes.length < 1 || volumes.length > defs_1.PA_MAX_CHANNELS)
            throw new Error("Expected between 1 and " + defs_1.PA_MAX_CHANNELS + " volume levels");
        _this.addCvolume(volumes);
        return _this;
    }
    return SetVolume;
}(SelectByNameOrIndex));
exports.SetVolume = SetVolume;
var SetVolumeByIndex = /** @class */ (function (_super) {
    __extends(SetVolumeByIndex, _super);
    function SetVolumeByIndex(cmd, index, volumes) {
        var _this = _super.call(this, cmd, index) || this;
        if (!Array.isArray(volumes))
            volumes = [volumes];
        if (volumes.length < 1 || volumes.length > defs_1.PA_MAX_CHANNELS)
            throw new Error("Expected between 1 and " + defs_1.PA_MAX_CHANNELS + " volume levels");
        _this.addCvolume(volumes);
        return _this;
    }
    return SetVolumeByIndex;
}(SelectByIndex));
exports.SetVolumeByIndex = SetVolumeByIndex;
var SetMute = /** @class */ (function (_super) {
    __extends(SetMute, _super);
    function SetMute(cmd, nameOrIndex, mute) {
        var _this = _super.call(this, cmd, nameOrIndex) || this;
        if (typeof mute !== 'boolean')
            throw new Error('Mute value must be a boolean');
        _this.addBool(mute);
        return _this;
    }
    return SetMute;
}(SelectByNameOrIndex));
exports.SetMute = SetMute;
var SetMuteByIndex = /** @class */ (function (_super) {
    __extends(SetMuteByIndex, _super);
    function SetMuteByIndex(cmd, index, mute) {
        var _this = _super.call(this, cmd, index) || this;
        if (typeof mute !== 'boolean')
            throw new Error('Value must be a boolean');
        _this.addBool(mute);
        return _this;
    }
    return SetMuteByIndex;
}(SelectByIndex));
exports.SetMuteByIndex = SetMuteByIndex;
var Lookup = /** @class */ (function (_super) {
    __extends(Lookup, _super);
    function Lookup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Lookup.prototype.processResponse = function (packet) {
        return packet.getUInt32();
    };
    return Lookup;
}(SelectByName));
exports.Lookup = Lookup;
function parseSourceSink(packet) {
    var rv = {
        index: packet.getUInt32(),
        name: packet.getString(),
        description: packet.getString(),
        sampleSpec: packet.getSampleSpec(),
        channelMap: packet.getChannelMap(),
        module: packet.getUInt32(),
        volume: {
            current: packet.getCvolume(),
        },
        mute: packet.getBool(),
        monitor: {
            index: packet.getUInt32(),
            name: packet.getString(),
        },
        latency: {
            current: packet.getUsec()
        },
        driver: packet.getString(),
        flags: packet.getUInt32()
    };
    // client version >= 13
    rv.properties = packet.getProps();
    rv.latency.requested = packet.getUsec();
    // client version >= 15
    rv.volume.base = packet.getVolume();
    rv.state = packet.getUInt32();
    rv.volume.steps = packet.getUInt32();
    rv.card = packet.getUInt32();
    // client version >= 16
    rv.ports = [];
    var ports = packet.getUInt32();
    for (var i = 0; i < ports; i++) {
        rv.ports.push({
            name: packet.getString(),
            description: packet.getString(),
            priority: packet.getUInt32(),
            available: packet.getUInt32() // client version >= 24
        });
    }
    rv.activePort = packet.getString();
    // client version >= 21
    rv.formats = [];
    var formats = packet.getUInt8();
    for (var i = 0; i < formats; i++)
        rv.formats.push(packet.getFormatInfo());
    return rv;
}
var GetSourceSinkInfo = /** @class */ (function (_super) {
    __extends(GetSourceSinkInfo, _super);
    function GetSourceSinkInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetSourceSinkInfo.prototype.processResponse = function (packet) {
        return parseSourceSink(packet);
    };
    return GetSourceSinkInfo;
}(SelectByNameOrIndex));
exports.GetSourceSinkInfo = GetSourceSinkInfo;
var GetSourceSinkInfoList = /** @class */ (function (_super) {
    __extends(GetSourceSinkInfoList, _super);
    function GetSourceSinkInfoList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetSourceSinkInfoList.prototype.processResponse = function (packet) {
        var rv = [];
        while (packet.i < packet.body.length)
            rv.push(parseSourceSink(packet));
        return rv;
    };
    return GetSourceSinkInfoList;
}(Command));
exports.GetSourceSinkInfoList = GetSourceSinkInfoList;
var LoadModule = /** @class */ (function (_super) {
    __extends(LoadModule, _super);
    function LoadModule(name, args) {
        var _this = _super.call(this, PA_COMMAND.LOAD_MODULE, name) || this;
        _this.addString(LoadModule.argsToString(args || {}));
        return _this;
    }
    LoadModule.argsToString = function (args) {
        var rv = '';
        for (var _i = 0, _a = Object.entries(args); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], val = _b[1];
            if (rv.length)
                rv += ' ';
            rv += key + "=";
            switch (typeof val) {
                case 'string':
                    rv += "'" + val.replace(/([^\\])'/g, "$1\\'") + "'";
                    break;
                case 'object':
                    rv += "\"" + LoadModule.argsToString((0, props_1.deflate)((val || {}))).replace(/([^\\])"/g, '$1\\"') + "\"";
                    break;
                case 'number':
                case 'boolean':
                    rv += "" + val;
                    break;
                default:
                    throw new Error("Unsupported value type for argument " + key);
            }
        }
        return rv;
    };
    LoadModule.prototype.processResponse = function (packet) {
        return packet.getUInt32();
    };
    return LoadModule;
}(SelectByName));
exports.LoadModule = LoadModule;
var PlaySample = /** @class */ (function (_super) {
    __extends(PlaySample, _super);
    function PlaySample(name, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = this;
        opts = __assign(__assign({}, PlaySample.defaults), opts);
        if (typeof name !== 'string' || !name.length)
            throw new Error('Sample name must be a non-empty string');
        if (typeof opts.volume !== 'number')
            throw new Error('Sample volume must be a number');
        _this = _super.call(this, PA_COMMAND.PLAY_SAMPLE, opts.sink) || this;
        _this.addUInt32(opts.volume);
        _this.addString(name);
        _this.addProps(opts.properties);
        return _this;
    }
    PlaySample.prototype.processResponse = function (packet) {
        return packet.getUInt32();
    };
    PlaySample.defaults = {
        volume: volume_1.PA_VOLUME_NORM,
        sink: defs_1.PA_DEFAULT_SINK,
        properties: {}
    };
    return PlaySample;
}(SelectByNameOrIndex));
exports.PlaySample = PlaySample;
var Subscribe = /** @class */ (function (_super) {
    __extends(Subscribe, _super);
    function Subscribe(mask) {
        var _this = _super.call(this, PA_COMMAND.SUBSCRIBE) || this;
        _this.addUInt32(mask);
        return _this;
    }
    return Subscribe;
}(Command));
exports.Subscribe = Subscribe;
var GetSinkInputInfo = /** @class */ (function (_super) {
    __extends(GetSinkInputInfo, _super);
    function GetSinkInputInfo(index) {
        return _super.call(this, PA_COMMAND.GET_SINK_INPUT_INFO, index) || this;
    }
    GetSinkInputInfo.prototype.processResponse = function (packet) {
        return {
            index: packet.getUInt32(),
            name: packet.getString(),
            module: packet.getUInt32(),
            client: packet.getUInt32(),
            sink: packet.getUInt32(),
            sampleSpec: packet.getSampleSpec(),
            channelMap: packet.getChannelMap(),
            volume: packet.getCvolume(),
            latency: {
                minimum: packet.getUsec(),
                maximum: packet.getUsec()
            },
            resampleMethod: packet.getString(),
            driver: packet.getString(),
            muted: packet.getBool(),
            properties: packet.getProps(),
            corked: packet.getBool(),
            hasVolume: packet.getBool(),
            writableVolume: packet.getBool(),
            formatInfo: packet.getFormatInfo()
        };
    };
    return GetSinkInputInfo;
}(SelectByIndex));
exports.GetSinkInputInfo = GetSinkInputInfo;
//See https://github.com/pulseaudio/pulseaudio/blob/7f4d7fcf5f6407913e50604c6195d0d5356195b1/src/pulsecore/protocol-native.c#L3440
function parseSourceOutputInfoPacket(packet) {
    return {
        index: packet.getUInt32(),
        name: packet.getString(),
        module: packet.getUInt32(),
        client: packet.getUInt32(),
        source: packet.getUInt32(),
        sampleSpec: packet.getSampleSpec(),
        channelMap: packet.getChannelMap(),
        latency: {
            minimum: packet.getUsec(),
            maximum: packet.getUsec()
        },
        resampleMethod: packet.getString(),
        driver: packet.getString(),
        properties: packet.getProps(),
        corked: packet.getBool(),
        volume: packet.getCvolume(),
        muted: packet.getBool(),
        hasVolume: packet.getBool(),
        writableVolume: packet.getBool(),
        formatInfo: packet.getFormatInfo()
    };
}
var GetSourceOutputInfo = /** @class */ (function (_super) {
    __extends(GetSourceOutputInfo, _super);
    function GetSourceOutputInfo(index) {
        return _super.call(this, PA_COMMAND.GET_SOURCE_OUTPUT_INFO, index) || this;
    }
    GetSourceOutputInfo.prototype.processResponse = function (packet) {
        return parseSourceOutputInfoPacket(packet);
    };
    return GetSourceOutputInfo;
}(SelectByIndex));
exports.GetSourceOutputInfo = GetSourceOutputInfo;
var CreateStream = /** @class */ (function (_super) {
    __extends(CreateStream, _super);
    function CreateStream(cmd) {
        var _this = _super.call(this, cmd) || this;
        _this.type = CreateStream.cmdToType(cmd);
        return _this;
    }
    CreateStream.cmdToType = function (cmd) {
        switch (cmd) {
            case PA_COMMAND.CREATE_UPLOAD_STREAM: return 'upload';
            case PA_COMMAND.CREATE_PLAYBACK_STREAM: return 'playback';
            case PA_COMMAND.CREATE_RECORD_STREAM: return 'record';
            default: throw new Error("Unsupported command " + cmd);
        }
    };
    CreateStream.parseOpts = function (opts, defaults) {
        if (defaults === void 0) { defaults = {}; }
        var o = __assign(__assign({}, defaults), opts);
        if (o.sampleSpec === null)
            throw new Error("Property 'sampleSpec' must be provided");
        // If the caller did not provide a channel map, create a default one based
        // on the number of channels specified in sampleSpec
        if (o.channelMap === null)
            o.channelMap = (0, wav_1.wavToChannelMap)(o.sampleSpec.channels);
        // If the volume property was not provided, configure all channels with
        // maximum volume
        if (o.volume === null)
            o.volume = Array(o.sampleSpec.channels).fill(volume_1.PA_VOLUME_NORM);
        return o;
    };
    CreateStream.prototype._addFormats = function (formats) {
        this.addUInt8(formats.length);
        for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {
            var fmt = formats_1[_i];
            if (!Array.isArray(fmt))
                fmt = [fmt];
            this.addFormatInfo(fmt[0], fmt[1]);
        }
    };
    return CreateStream;
}(Command));
var CreatePlaybackStream = /** @class */ (function (_super) {
    __extends(CreatePlaybackStream, _super);
    function CreatePlaybackStream(opts, cmd) {
        if (opts === void 0) { opts = {}; }
        if (cmd === void 0) { cmd = PA_COMMAND.CREATE_PLAYBACK_STREAM; }
        var _this = _super.call(this, cmd) || this;
        opts = CreateStream.parseOpts(opts, CreatePlaybackStream.defaults);
        _this.opts = opts;
        _this.addSampleSpec(opts.sampleSpec);
        _this.addChannelMap(opts.channelMap);
        _this.addUInt32(opts.index);
        _this.addString(opts.name);
        _this.addUInt32(opts.maximumLength);
        _this.addBool(opts.corked);
        _this.addUInt32(opts.targetLength);
        _this.addUInt32(opts.preBuffering);
        _this.addUInt32(opts.minimumRequest);
        _this.addUInt32(typeof opts.syncId === 'undefined' ? syncIdCounter : opts.syncId);
        _this.addCvolume(opts.volume);
        _this.addBool(opts.noRemap);
        _this.addBool(opts.noRemix);
        _this.addBool(opts.fixFormat);
        _this.addBool(opts.fixRate);
        _this.addBool(opts.fixChannels);
        _this.addBool(opts.noMove);
        _this.addBool(opts.variableRate);
        _this.addBool(opts.muted);
        _this.addBool(opts.adjustLatency);
        _this.addProps(opts.properties);
        _this.addBool(opts.volumeSet);
        _this.addBool(opts.earlyRequests);
        _this.addBool(opts.mutedSet);
        _this.addBool(opts.dontInhibitAutoSuspend);
        _this.addBool(opts.failOnSuspend);
        _this.addBool(opts.relativeVolume);
        _this.addBool(opts.passthrough);
        _this._addFormats(opts.formats);
        // Every time we create a new playback stream, increment the globally unique
        // syncId counter so that its value is unique when the next stream is
        // created. This minimizes the probability that two streams that are not
        // meant to be synchronized will get the same syncId
        syncIdCounter++;
        return _this;
    }
    CreatePlaybackStream.prototype.processResponse = function (packet, pulseaudio) {
        var s = new stream_1.PlaybackStream(pulseaudio, {
            index: packet.getUInt32(),
            sinkInput: packet.getUInt32(),
            requestedBytes: packet.getUInt32(),
            maximumLength: this.opts.maximumLength,
            buffer: {
                maximumLength: packet.getUInt32(),
                targetLength: packet.getUInt32(),
                preBuffering: packet.getUInt32(),
                minimumRequest: packet.getUInt32()
            },
            sampleSpec: packet.getSampleSpec(),
            channelMap: packet.getChannelMap(),
            sink: {
                index: packet.getUInt32(),
                name: packet.getString(),
                suspended: packet.getBool()
            },
            configuredSinkLatency: packet.getUsec(),
            format: packet.getFormatInfo()
        });
        pulseaudio.streams.playback[s.index] = s;
        s.once('close', function () {
            delete pulseaudio.streams.playback[s.index];
        });
        return s;
    };
    CreatePlaybackStream.defaults = {
        sampleSpec: null,
        channelMap: null,
        index: defs_1.PA_NO_INDEX,
        name: null,
        maximumLength: defs_1.PA_NO_VALUE,
        corked: false,
        properties: {},
        targetLength: defs_1.PA_NO_VALUE,
        preBuffering: defs_1.PA_NO_VALUE,
        minimumRequest: defs_1.PA_NO_VALUE,
        volume: null,
        noRemap: false,
        noRemix: false,
        fixFormat: false,
        fixRate: false,
        fixChannels: false,
        noMove: false,
        variableRate: false,
        muted: false,
        adjustLatency: false,
        volumeSet: true,
        earlyRequests: false,
        mutedSet: false,
        dontInhibitAutoSuspend: false,
        failOnSuspend: false,
        relativeVolume: false,
        passthrough: false,
        formats: []
    };
    return CreatePlaybackStream;
}(CreateStream));
exports.CreatePlaybackStream = CreatePlaybackStream;
var CreateUploadStream = /** @class */ (function (_super) {
    __extends(CreateUploadStream, _super);
    function CreateUploadStream(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, PA_COMMAND.CREATE_UPLOAD_STREAM) || this;
        opts = CreateStream.parseOpts(opts, CreateUploadStream.defaults);
        if (opts.name === null)
            throw new Error("Please provide a name for upload stream");
        // For upload streams, we must provide the size of the wav file to the
        // PulseAudio server. It uses the value to allocate a memory buffer for the
        // sample.
        if (opts.maximumLength === null)
            throw new Error("Please provide a value for attribute maximumLength");
        _this.opts = opts;
        _this.addString(opts.name);
        _this.addSampleSpec(opts.sampleSpec);
        _this.addChannelMap(opts.channelMap);
        _this.addUInt32(opts.maximumLength);
        _this.addProps(opts.properties);
        return _this;
    }
    CreateUploadStream.prototype.processResponse = function (packet, pulseaudio) {
        var s = new stream_1.UploadStream(pulseaudio, {
            index: packet.getUInt32(),
            requestedBytes: packet.getUInt32(),
            maximumLength: this.opts.maximumLength,
            sampleSpec: this.opts.sampleSpec
        });
        pulseaudio.streams.upload[s.index] = s;
        s.once('close', function () {
            delete pulseaudio.streams.upload[s.index];
        });
        return s;
    };
    CreateUploadStream.defaults = {
        name: null,
        sampleSpec: null,
        channelMap: null,
        maximumLength: null,
        properties: {}
    };
    return CreateUploadStream;
}(CreateStream));
exports.CreateUploadStream = CreateUploadStream;
var CreateRecordStream = /** @class */ (function (_super) {
    __extends(CreateRecordStream, _super);
    function CreateRecordStream(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, PA_COMMAND.CREATE_RECORD_STREAM) || this;
        opts = CreateStream.parseOpts(opts, CreateRecordStream.defaults);
        _this.opts = opts;
        _this.addSampleSpec(opts.sampleSpec);
        _this.addChannelMap(opts.channelMap);
        _this.addUInt32(opts.index);
        _this.addString(opts.name);
        _this.addUInt32(opts.maximumLength);
        _this.addBool(opts.corked);
        _this.addUInt32(opts.fragmentSize);
        _this.addBool(opts.noRemap);
        _this.addBool(opts.noRemix);
        _this.addBool(opts.fixFormat);
        _this.addBool(opts.fixRate);
        _this.addBool(opts.fixChannels);
        _this.addBool(opts.noMove);
        _this.addBool(opts.variableRate);
        _this.addBool(opts.peakDetect);
        _this.addBool(opts.adjustLatency);
        _this.addProps(opts.properties);
        _this.addUInt32(opts.directOnInputIndex);
        _this.addBool(opts.earlyRequests);
        _this.addBool(opts.dontInhibitAutoSuspend);
        _this.addBool(opts.failOnSuspend);
        _this._addFormats(opts.formats);
        _this.addCvolume(opts.volume);
        _this.addBool(opts.muted);
        _this.addBool(opts.volumeSet);
        _this.addBool(opts.mutedSet);
        _this.addBool(opts.relativeVolume);
        _this.addBool(opts.passthrough);
        return _this;
    }
    CreateRecordStream.prototype.processResponse = function (packet, pulseaudio) {
        var s = new stream_1.RecordStream(pulseaudio, {
            index: packet.getUInt32(),
            sourceOutput: packet.getUInt32(),
            maximumLength: this.opts.maximumLength,
            buffer: {
                maximumLength: packet.getUInt32(),
                fragmentSize: packet.getUInt32()
            },
            sampleSpec: packet.getSampleSpec(),
            channelMap: packet.getChannelMap(),
            source: {
                index: packet.getUInt32(),
                name: packet.getString(),
                suspended: packet.getBool()
            },
            configuredSourceLatency: packet.getUsec(),
            format: packet.getFormatInfo()
        });
        pulseaudio.streams.record[s.index] = s;
        s.once('close', function () {
            delete pulseaudio.streams.record[s.index];
        });
        return s;
    };
    CreateRecordStream.defaults = {
        sampleSpec: null,
        channelMap: null,
        index: defs_1.PA_NO_INDEX,
        name: null,
        maximumLength: defs_1.PA_NO_VALUE,
        corked: false,
        fragmentSize: defs_1.PA_NO_VALUE,
        noRemap: false,
        noRemix: false,
        fixFormat: false,
        fixRate: false,
        fixChannels: false,
        noMove: false,
        variableRate: false,
        peakDetect: false,
        adjustLatency: false,
        properties: {},
        directOnInputIndex: defs_1.PA_NO_VALUE,
        earlyRequests: false,
        dontInhibitAutoSuspend: false,
        failOnSuspend: false,
        formats: [],
        volume: null,
        muted: false,
        volumeSet: false,
        mutedSet: false,
        relativeVolume: false,
        passthrough: false
    };
    return CreateRecordStream;
}(CreateStream));
exports.CreateRecordStream = CreateRecordStream;
var GetClientsList = /** @class */ (function (_super) {
    __extends(GetClientsList, _super);
    function GetClientsList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetClientsList.prototype.processResponse = function (packet) {
        var rv = [];
        while (packet.i < packet.body.length) {
            rv.push({
                index: packet.getUInt32(),
                name: packet.getString(),
                ownerModule: packet.getUInt32(),
                driver: packet.getString(),
                properties: packet.getProps()
            });
        }
        return rv;
    };
    return GetClientsList;
}(Command));
exports.GetClientsList = GetClientsList;
var GetSinkInputList = /** @class */ (function (_super) {
    __extends(GetSinkInputList, _super);
    function GetSinkInputList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetSinkInputList.prototype.processResponse = function (packet) {
        var rv = [];
        while (packet.i < packet.body.length) {
            rv.push({
                index: packet.getUInt32(),
                name: packet.getString(),
                module: packet.getUInt32(),
                client: packet.getUInt32(),
                sink: packet.getUInt32(),
                sampleSpec: packet.getSampleSpec(),
                channelMap: packet.getChannelMap(),
                volume: packet.getCvolume(),
                latency: {
                    minimum: packet.getUsec(),
                    maximum: packet.getUsec()
                },
                resampleMethod: packet.getString(),
                driver: packet.getString(),
                muted: packet.getBool(),
                properties: packet.getProps(),
                corked: packet.getBool(),
                hasVolume: packet.getBool(),
                writableVolume: packet.getBool(),
                formatInfo: packet.getFormatInfo()
            });
        }
        return rv;
    };
    return GetSinkInputList;
}(Command));
exports.GetSinkInputList = GetSinkInputList;
var GetSourceOutputList = /** @class */ (function (_super) {
    __extends(GetSourceOutputList, _super);
    function GetSourceOutputList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GetSourceOutputList.prototype.processResponse = function (packet) {
        var rv = [];
        while (packet.i < packet.body.length) {
            rv.push(parseSourceOutputInfoPacket(packet));
        }
        return rv;
    };
    return GetSourceOutputList;
}(Command));
exports.GetSourceOutputList = GetSourceOutputList;
var Move = /** @class */ (function (_super) {
    __extends(Move, _super);
    function Move(cmd, index, inputOrOutput) {
        var _this = _super.call(this, cmd, index) || this;
        switch (typeof inputOrOutput) {
            case 'number':
                _this.addUInt32(inputOrOutput);
                _this.addString(null);
                break;
            case 'string':
                _this.addUInt32(defs_1.PA_NO_INDEX);
                _this.addString(inputOrOutput);
                break;
            default:
                throw new Error('Parameter inputOrOutput must be number or string');
        }
        return _this;
    }
    return Move;
}(SelectByIndex));
exports.Move = Move;
